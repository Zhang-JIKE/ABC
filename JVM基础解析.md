# JVM基础解析
## 1. JVM内存模型
![JVM内存模型](https://user-images.githubusercontent.com/28483207/116843267-03ea2f00-ac12-11eb-8813-15cacb6ddcec.png)
### 1.1 程序计数器  <kbd>内存占用小</kbd> <kbd>唯一不会OOM</kbd>
> JVM的多线程是通过CPU时间片轮转来实现的，当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，
> 通过程序计数器来记录某个线程的字节码执行位置，就可以在被挂起的线程中从某个地方继续执行，因此每个线程工作时都有属于自己的独立计数器。
> 假设程序永远只有一个线程，则不需要程序计数器，但实际上程序是通过多个线程协同合作执行的，所以需要程序计数器的存在。
- 线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
- 正在执行的是 Native 方法，这个计数器的值则为 (Undefined)
### 1.2 虚拟机栈  <kbd>生命周期和线程一致</kbd>
![虚拟机栈](https://user-images.githubusercontent.com/28483207/117165315-f68e9980-adf7-11eb-8cf5-5bdfec1c6f57.png)
> 描述了 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)，每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
>
>
