# JVM基础解析
## 1. JVM内存模型
![JVM内存模型](https://user-images.githubusercontent.com/28483207/117580841-7d12e600-b12c-11eb-9e4a-abef00f33df4.png)
### 1.1 程序计数器  <kbd>内存占用小</kbd> <kbd>唯一不会OOM</kbd>
> JVM的多线程是通过CPU时间片轮转来实现的，当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，
> 通过程序计数器来记录某个线程的字节码执行位置，就可以在被挂起的线程中从某个地方继续执行，因此每个线程工作时都有属于自己的独立计数器。
> 假设程序永远只有一个线程，则不需要程序计数器，但实际上程序是通过多个线程协同合作执行的，所以需要程序计数器的存在。
- 线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
- 正在执行的是 Native 方法，这个计数器的值则为 (Undefined)
### 1.2 虚拟机栈  <kbd>生命周期和线程一致</kbd>
![虚拟机栈](https://user-images.githubusercontent.com/28483207/117582915-f57ea480-b136-11eb-8d3d-59fdcbffffd4.png)
> 描述了 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)，每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
- **局部变量表**

  存放了编译期可知的八种基本类型、引用类型和returnAddress 类型(指向了一条字节码指令的地址)
- **操作数栈**

  通过进出栈，实现对数据的操作
- **动态链接**

  每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）
- **方法出口**
